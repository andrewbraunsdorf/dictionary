Have to include dictionary.h in speller.c and dictionary.c
Ie # include dictionary.h
We use std bool.h where bool is defined
#define is a preprocessor directive that defines a constant and in the file automatically changes the code to define it via the #define  directive

Two items check and load take pointers for strings and dictionary
Const means you cant change the words accidentally or purposely

Defined struct called node in a hash table.  There is enough room for n pointers to nodes
N has been defined to 26 via the above...one for each letter

Hash function returns 0 for any word that starts with a or A and 1 for any word that starts with b or B.  25 for any word that starts with z or Z

Load is only partially completed.  It will load a dictionary of words into the hash table.
There is some code that initializes the buckets of pointers in the hash table (pointers to NULL
There is some code that opens a dictionary which then needs to be loaded
There is code that iterates over the dictionary and reads the woods therein one at a time into a buffer ie (string) called word.
Then we stop short of inserting these words into the hashtable.
We close the file and return true to indicate success

check, size, and unload, just barely implemented, ie to allow for the file to compile.
They need to be completed to check if the word exists

Speller.c
Checking the time it takes to execute using getrusage, which times the execution before and after

It will be benched marked by check load size and unload functions
Speller will not load dictionaries until you implement load in dictionary.c

The default dictionary has 143091 words, and all must be loaded into memory
Dictionary is sorted lexicographically, with only one word per line (each of which ends with \n)
No word is longer than 45 characters, and no word appears more than once.

Use ./speller dictionaries/small text because it uses a much smaller dictionary
Text is the file we want to check

Cannot alter speller.c


alter the value of N and the implementation of hash.

 spell checker must not leak any memory.

How many words can a spell checker check
Implement
Load- loads dictionary
Check- checks dictionary
Size- returns the number of words in the dictionary
Unload- frees the dictionary from memory

Load
For each word in the dictionary text file, store it in the dictionary’s data structure
Linked lists
Hash tables
Tries

Hash tables
An array of buckets
Hash function
	Returns the bucket that a given key belongs to

	Trouble cs50 balls
Have 10 numbered 1-10
Then put them into groups
Put them into even and odds tables
Hash table: 2 buckets
Hash function : if (n % 2 == 1, odd box, else even box

Now have 20 balls
Sort into 2 boxes but still too many
Sort them via 1-5, 6-10, 11-15, 16-20
Now they are nicely balanced...as you have the same number of balls in each box.

Hash table is an array of buckets
A hash table is an array of linked lists
Linked lists are comprised of nodes.
Each node has a value along with a pointer to the next node


Data type deals with char arrays
Link list, points to the next node,

Incorporate hash tables with linked lists, you have linked list inside of each bucket
Hash table with buckets and each integer has a value
Hash function, hash value and see which value it should be in and
Have to allocate space for each node
Malloc will need to know how much space to add
Malloc will give us our space
Whenever we are creating a node we just need to malloc a node pointer
If you wanted a second node, you would add a second node

// node *node1 = malloc(sizeof(node);
// node *node2 = malloc(sizeof(node);

// strcpy(node1->word, "Hello");
// strcpy(node2->word, "World");

// these are two independents nodes
// point to next variable
// node1->next = node2;
// link list of size 2

Hashtables are arrays of linked lists
Speller
Determine which hashtable the word fits into and hash the value and figure out which linked list it belongs to

We just want to malloc a node pointer
Now we want to set the value of the word
strcpy(node1->word, “hello”)
Sowe have to get this to occur programmatically… ie with word
So perform strcpy(node1->word, word)

Have to add access the next variable to create a linked list
So node1->next = node2;  again have to do this programmatically so
node1->next = NULL
Define hashtable size

What goes inside of while loop
while (fscanf(file, "%s", word) != EOF)

Every word we scan we want to malloc a node for it
node *newNode = malloc(sizeof(node));

        if (newNode == NULL)

            unload();
            return false;


We want to check that malloc succeeded
If you run out of memory malloc will return null
So when you malloc you always need to make sure it exists

Check
Case- insensitivity
Assume strings with only alphabetical characters and or apostrophes

Hashtable is an array of linked lists
With each element of the array is a node pointer
If the word exists it can be found in the hash table
Which bucket would it be in?
Hash table [hash(word)]

Search in that linked list
Strcasecmp

Traverse linked list
Node *cursor = head;
While (cursor != Null)
{
	// do something
	Cursor = cursor->next
}

You have to compare strings
Compare words
Cursor word
